
散列函数(Hash函数):
    散列函数是这样的函数，即无论你给它什么数据，它都还你一个数字。
    如果用专业术语来表达的话，我们会说，散列函数“将输入映射到数字”。你可能认为散列函数输出的数字没什么规律，但其实散列函数必须满足一些要求。
         它必须是一致的。例如，假设你输入apple时得到的是4，那么每次输入apple时，得到的都必须为4。如果不是这样，散列表将毫无用处。
         它应将不同的输入映射到不同的数字。
    散列函数准确地指出了价格的存储位置，你根本不用查找！之所以能够这样，具体原因如下。
         散列函数总是将同样的输入映射到相同的索引。每次你输入avocado，得到的都是同一个数字。因此，你可首先使用它来确定将鳄梨的价格存储
           在什么地方，并在以后使用它来确定鳄梨的价格存储在什么地方。
         散列函数将不同的输入映射到不同的索引。 avocado映射到索引4， milk映射到索引0。每种商品都映射到数组的不同位置，让你能够将其价格存储到这里。
         散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会返回无效索引100。
    结合使用散列函数和数组创建了一种被称为散列表（hash table）的数据结构。散列表是你学习的第一种包含额外逻辑的数据结构。数组和链表都被直接映
        射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置。

    在复杂数据结构中，散列表可能是最有用的，也被称为散列映射、映射、字典和关联数组。散列表的速度很快！你可以立即获取数组中的元素，
        而散列表也使用数组来存储数据，因此其获取元素的速度与数组一样快。

    为了防止输入的信息重复最好使用Hashtable去存储，那就是使用散列表！
    缓存的数据则存储在散列表中
小结
    这里总结一下，散列表适合用于：
         模拟映射关系；
         防止重复；
         缓存/记住数据，以免服务器再通过处理来生成它们。

散列表的冲突和性能：
    如果两个键映射到了同一个位置，就在这个位置存储一个链表。
    这里的经验教训有两个。
         散列函数很重要。前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，散列函数将键均匀地映射到散列表的不同位置。
         如果散列表存储的链表很长，散列表的速度将急剧下降。然而， 如果使用的散列函数很好，这些链表就不会很长！
    在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者的优点
    为了避免冲突，需要有：
         较低的填装因子；
         良好的散列函数
    填装因子：散列表中的元素个数/位置总数
        例子： 在散列表中存储100种商品的价格，而该散列表包含100个位置则填装因子为1，如果散列表只有50个位置，则填充因子将为2

        一旦填装因子开始增大，你就需要在散列表中添加位置，这被称为调整长度（resizing）
        一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度。
    良好的散列函数
        良好的散列函数让数组中的值呈均匀分布。
        糟糕的散列函数让值扎堆，导致大量的冲突。

小结
    散列表是一种功能强大的数据结构，其操作速度快，还能让你以不同的方式建立数据模型
     你可以结合散列函数和数组来创建散列表。
     冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。
     散列表的查找、插入和删除速度都非常快。
     散列表适合用于模拟映射关系。
     一旦填装因子超过0.7，就该调整散列表的长度。
     散列表可用于缓存数据（例如，在Web服务器上）。
     散列表非常适合用于防止重复